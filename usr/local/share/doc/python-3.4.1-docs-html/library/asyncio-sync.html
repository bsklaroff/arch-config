<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>18.5.7. Synchronization primitives &mdash; Python 3.4.1 documentation</title>
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.4.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python 3.4.1 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python 3.4.1 documentation" href="../index.html" />
    <link rel="up" title="18.5. asyncio – Asynchronous I/O, event loop, coroutines and tasks" href="asyncio.html" />
    <link rel="next" title="18.5.8. Develop with asyncio" href="asyncio-dev.html" />
    <link rel="prev" title="18.5.6. Subprocess" href="asyncio-subprocess.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/version_switch.js"></script>
    
 

  </head>
  <body>  
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="asyncio-dev.html" title="18.5.8. Develop with asyncio"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="asyncio-subprocess.html" title="18.5.6. Subprocess"
             accesskey="P">previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.4.1</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li><a href="index.html" >The Python Standard Library</a> &raquo;</li>
          <li><a href="ipc.html" >18. Interprocess Communication and Networking</a> &raquo;</li>
          <li><a href="asyncio.html" accesskey="U">18.5. <tt class="docutils literal"><span class="pre">asyncio</span></tt> &#8211; Asynchronous I/O, event loop, coroutines and tasks</a> &raquo;</li> 
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="synchronization-primitives">
<span id="asyncio-sync"></span><h1>18.5.7. Synchronization primitives<a class="headerlink" href="#synchronization-primitives" title="Permalink to this headline">¶</a></h1>
<div class="section" id="locks">
<h2>18.5.7.1. Locks<a class="headerlink" href="#locks" title="Permalink to this headline">¶</a></h2>
<div class="section" id="lock">
<h3>18.5.7.1.1. Lock<a class="headerlink" href="#lock" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="asyncio.Lock">
<em class="property">class </em><tt class="descclassname">asyncio.</tt><tt class="descname">Lock</tt><big>(</big><em>*</em>, <em>loop=None</em><big>)</big><a class="headerlink" href="#asyncio.Lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Primitive lock objects.</p>
<p>A primitive lock is a synchronization primitive that is not owned by a
particular coroutine when locked.  A primitive lock is in one of two states,
&#8216;locked&#8217; or &#8216;unlocked&#8217;.</p>
<p>It is created in the unlocked state.  It has two basic methods, <a class="reference internal" href="#asyncio.Lock.acquire" title="asyncio.Lock.acquire"><tt class="xref py py-meth docutils literal"><span class="pre">acquire()</span></tt></a>
and <a class="reference internal" href="#asyncio.Lock.release" title="asyncio.Lock.release"><tt class="xref py py-meth docutils literal"><span class="pre">release()</span></tt></a>.  When the state is unlocked, acquire() changes the state to
locked and returns immediately.  When the state is locked, acquire() blocks
until a call to release() in another coroutine changes it to unlocked, then
the acquire() call resets it to locked and returns.  The release() method
should only be called in the locked state; it changes the state to unlocked
and returns immediately.  If an attempt is made to release an unlocked lock,
a <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> will be raised.</p>
<p>When more than one coroutine is blocked in acquire() waiting for the state
to turn to unlocked, only one coroutine proceeds when a release() call
resets the state to unlocked; first coroutine which is blocked in acquire()
is being processed.</p>
<p><a class="reference internal" href="#asyncio.Lock.acquire" title="asyncio.Lock.acquire"><tt class="xref py py-meth docutils literal"><span class="pre">acquire()</span></tt></a> is a coroutine and should be called with <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span></tt>.</p>
<p>Locks also support the context manager protocol.  <tt class="docutils literal"><span class="pre">(yield</span> <span class="pre">from</span> <span class="pre">lock)</span></tt>
should be used as context manager expression.</p>
<p>Usage:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
<span class="o">...</span>
<span class="k">yield from</span> <span class="n">lock</span>
<span class="k">try</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</pre></div>
</div>
<p>Context manager usage:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
<span class="o">...</span>
<span class="k">with</span> <span class="p">(</span><span class="k">yield from</span> <span class="n">lock</span><span class="p">):</span>
     <span class="o">...</span>
</pre></div>
</div>
<p>Lock objects can be tested for locking state:</p>
<div class="highlight-python3"><div class="highlight"><pre><span class="k">if</span> <span class="ow">not</span> <span class="n">lock</span><span class="o">.</span><span class="n">locked</span><span class="p">():</span>
   <span class="k">yield from</span> <span class="n">lock</span>
<span class="k">else</span><span class="p">:</span>
   <span class="c"># lock is acquired</span>
    <span class="o">...</span>
</pre></div>
</div>
<dl class="method">
<dt id="asyncio.Lock.locked">
<tt class="descname">locked</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.Lock.locked" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if the lock is acquired.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Lock.acquire">
<tt class="descname">acquire</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.Lock.acquire" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire a lock.</p>
<p>This method blocks until the lock is unlocked, then sets it to locked and
returns <tt class="docutils literal"><span class="pre">True</span></tt>.</p>
<p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Lock.release">
<tt class="descname">release</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.Lock.release" title="Permalink to this definition">¶</a></dt>
<dd><p>Release a lock.</p>
<p>When the lock is locked, reset it to unlocked, and return.  If any other
coroutines are blocked waiting for the lock to become unlocked, allow
exactly one of them to proceed.</p>
<p>When invoked on an unlocked lock, a <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> is raised.</p>
<p>There is no return value.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="event">
<h3>18.5.7.1.2. Event<a class="headerlink" href="#event" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="asyncio.Event">
<em class="property">class </em><tt class="descclassname">asyncio.</tt><tt class="descname">Event</tt><big>(</big><em>*</em>, <em>loop=None</em><big>)</big><a class="headerlink" href="#asyncio.Event" title="Permalink to this definition">¶</a></dt>
<dd><p>An Event implementation, asynchronous equivalent to <a class="reference internal" href="threading.html#threading.Event" title="threading.Event"><tt class="xref py py-class docutils literal"><span class="pre">threading.Event</span></tt></a>.</p>
<p>Class implementing event objects. An event manages a flag that can be set to
true with the <a class="reference internal" href="stdtypes.html#set" title="set"><tt class="xref py py-meth docutils literal"><span class="pre">set()</span></tt></a> method and reset to false with the <a class="reference internal" href="#asyncio.Event.clear" title="asyncio.Event.clear"><tt class="xref py py-meth docutils literal"><span class="pre">clear()</span></tt></a>
method.  The <a class="reference internal" href="asyncio-task.html#asyncio.wait" title="asyncio.wait"><tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt></a> method blocks until the flag is true. The flag is
initially false.</p>
<dl class="method">
<dt id="asyncio.Event.clear">
<tt class="descname">clear</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.Event.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the internal flag to false. Subsequently, coroutines calling
<a class="reference internal" href="asyncio-task.html#asyncio.wait" title="asyncio.wait"><tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt></a> will block until <a class="reference internal" href="stdtypes.html#set" title="set"><tt class="xref py py-meth docutils literal"><span class="pre">set()</span></tt></a> is called to set the internal
flag to true again.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Event.is_set">
<tt class="descname">is_set</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.Event.is_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if and only if the internal flag is true.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Event.set">
<tt class="descname">set</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.Event.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the internal flag to true. All coroutines waiting for it to become
true are awakened. Coroutine that call <a class="reference internal" href="asyncio-task.html#asyncio.wait" title="asyncio.wait"><tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt></a> once the flag is true
will not block at all.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Event.wait">
<tt class="descname">wait</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.Event.wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Block until the internal flag is true.</p>
<p>If the internal flag is true on entry, return <tt class="docutils literal"><span class="pre">True</span></tt> immediately.
Otherwise, block until another coroutine calls <a class="reference internal" href="stdtypes.html#set" title="set"><tt class="xref py py-meth docutils literal"><span class="pre">set()</span></tt></a> to set the
flag to true, then return <tt class="docutils literal"><span class="pre">True</span></tt>.</p>
<p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="condition">
<h3>18.5.7.1.3. Condition<a class="headerlink" href="#condition" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="asyncio.Condition">
<em class="property">class </em><tt class="descclassname">asyncio.</tt><tt class="descname">Condition</tt><big>(</big><em>*</em>, <em>loop=None</em><big>)</big><a class="headerlink" href="#asyncio.Condition" title="Permalink to this definition">¶</a></dt>
<dd><p>A Condition implementation, asynchronous equivalent to
<a class="reference internal" href="threading.html#threading.Condition" title="threading.Condition"><tt class="xref py py-class docutils literal"><span class="pre">threading.Condition</span></tt></a>.</p>
<p>This class implements condition variable objects. A condition variable
allows one or more coroutines to wait until they are notified by another
coroutine.</p>
<p>A new <a class="reference internal" href="#asyncio.Lock" title="asyncio.Lock"><tt class="xref py py-class docutils literal"><span class="pre">Lock</span></tt></a> object is created and used as the underlying lock.</p>
<dl class="method">
<dt id="asyncio.Condition.acquire">
<tt class="descname">acquire</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.Condition.acquire" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire the underlying lock.</p>
<p>This method blocks until the lock is unlocked, then sets it to locked and
returns <tt class="docutils literal"><span class="pre">True</span></tt>.</p>
<p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Condition.notify">
<tt class="descname">notify</tt><big>(</big><em>n=1</em><big>)</big><a class="headerlink" href="#asyncio.Condition.notify" title="Permalink to this definition">¶</a></dt>
<dd><p>By default, wake up one coroutine waiting on this condition, if any.
If the calling coroutine has not acquired the lock when this method is
called, a <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> is raised.</p>
<p>This method wakes up at most <em>n</em> of the coroutines waiting for the
condition variable; it is a no-op if no coroutines are waiting.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">An awakened coroutine does not actually return from its <a class="reference internal" href="asyncio-task.html#asyncio.wait" title="asyncio.wait"><tt class="xref py py-meth docutils literal"><span class="pre">wait()</span></tt></a>
call until it can reacquire the lock. Since <a class="reference internal" href="#asyncio.Condition.notify" title="asyncio.Condition.notify"><tt class="xref py py-meth docutils literal"><span class="pre">notify()</span></tt></a> does not
release the lock, its caller should.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.Condition.locked">
<tt class="descname">locked</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.Condition.locked" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if the underlying lock is acquired.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Condition.notify_all">
<tt class="descname">notify_all</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.Condition.notify_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Wake up all threads waiting on this condition. This method acts like
<a class="reference internal" href="#asyncio.Condition.notify" title="asyncio.Condition.notify"><tt class="xref py py-meth docutils literal"><span class="pre">notify()</span></tt></a>, but wakes up all waiting threads instead of one. If the
calling thread has not acquired the lock when this method is called, a
<a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> is raised.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Condition.release">
<tt class="descname">release</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.Condition.release" title="Permalink to this definition">¶</a></dt>
<dd><p>Release the underlying lock.</p>
<p>When the lock is locked, reset it to unlocked, and return. If any other
coroutines are blocked waiting for the lock to become unlocked, allow
exactly one of them to proceed.</p>
<p>When invoked on an unlocked lock, a <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> is raised.</p>
<p>There is no return value.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Condition.wait">
<tt class="descname">wait</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.Condition.wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait until notified.</p>
<p>If the calling coroutine has not acquired the lock when this method is
called, a <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><tt class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></tt></a> is raised.</p>
<p>This method releases the underlying lock, and then blocks until it is
awakened by a <a class="reference internal" href="#asyncio.Condition.notify" title="asyncio.Condition.notify"><tt class="xref py py-meth docutils literal"><span class="pre">notify()</span></tt></a> or <a class="reference internal" href="#asyncio.Condition.notify_all" title="asyncio.Condition.notify_all"><tt class="xref py py-meth docutils literal"><span class="pre">notify_all()</span></tt></a> call for the same
condition variable in another coroutine.  Once awakened, it re-acquires
the lock and returns <tt class="docutils literal"><span class="pre">True</span></tt>.</p>
<p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Condition.wait_for">
<tt class="descname">wait_for</tt><big>(</big><em>predicate</em><big>)</big><a class="headerlink" href="#asyncio.Condition.wait_for" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait until a predicate becomes true.</p>
<p>The predicate should be a callable which result will be interpreted as a
boolean value. The final predicate value is the return value.</p>
<p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a>.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="semaphores">
<h2>18.5.7.2. Semaphores<a class="headerlink" href="#semaphores" title="Permalink to this headline">¶</a></h2>
<div class="section" id="semaphore">
<h3>18.5.7.2.1. Semaphore<a class="headerlink" href="#semaphore" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="asyncio.Semaphore">
<em class="property">class </em><tt class="descclassname">asyncio.</tt><tt class="descname">Semaphore</tt><big>(</big><em>value=1</em>, <em>*</em>, <em>loop=None</em><big>)</big><a class="headerlink" href="#asyncio.Semaphore" title="Permalink to this definition">¶</a></dt>
<dd><p>A Semaphore implementation.</p>
<p>A semaphore manages an internal counter which is decremented by each
<a class="reference internal" href="#asyncio.Semaphore.acquire" title="asyncio.Semaphore.acquire"><tt class="xref py py-meth docutils literal"><span class="pre">acquire()</span></tt></a> call and incremented by each <a class="reference internal" href="#asyncio.Semaphore.release" title="asyncio.Semaphore.release"><tt class="xref py py-meth docutils literal"><span class="pre">release()</span></tt></a> call. The
counter can never go below zero; when <a class="reference internal" href="#asyncio.Semaphore.acquire" title="asyncio.Semaphore.acquire"><tt class="xref py py-meth docutils literal"><span class="pre">acquire()</span></tt></a> finds that it is zero,
it blocks, waiting until some other thread calls <a class="reference internal" href="#asyncio.Semaphore.release" title="asyncio.Semaphore.release"><tt class="xref py py-meth docutils literal"><span class="pre">release()</span></tt></a>.</p>
<p>Semaphores also support the context manager protocol.</p>
<p>The optional argument gives the initial value for the internal counter; it
defaults to <tt class="docutils literal"><span class="pre">1</span></tt>. If the value given is less than <tt class="docutils literal"><span class="pre">0</span></tt>, <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a>
is raised.</p>
<dl class="method">
<dt id="asyncio.Semaphore.acquire">
<tt class="descname">acquire</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.Semaphore.acquire" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire a semaphore.</p>
<p>If the internal counter is larger than zero on entry, decrement it by one
and return <tt class="docutils literal"><span class="pre">True</span></tt> immediately.  If it is zero on entry, block, waiting
until some other coroutine has called <a class="reference internal" href="#asyncio.Semaphore.release" title="asyncio.Semaphore.release"><tt class="xref py py-meth docutils literal"><span class="pre">release()</span></tt></a> to make it larger
than <tt class="docutils literal"><span class="pre">0</span></tt>, and then return <tt class="docutils literal"><span class="pre">True</span></tt>.</p>
<p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Semaphore.locked">
<tt class="descname">locked</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.Semaphore.locked" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <tt class="docutils literal"><span class="pre">True</span></tt> if semaphore can not be acquired immediately.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Semaphore.release">
<tt class="descname">release</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.Semaphore.release" title="Permalink to this definition">¶</a></dt>
<dd><p>Release a semaphore, incrementing the internal counter by one. When it
was zero on entry and another coroutine is waiting for it to become
larger than zero again, wake up that coroutine.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="boundedsemaphore">
<h3>18.5.7.2.2. BoundedSemaphore<a class="headerlink" href="#boundedsemaphore" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="asyncio.BoundedSemaphore">
<em class="property">class </em><tt class="descclassname">asyncio.</tt><tt class="descname">BoundedSemaphore</tt><big>(</big><em>value=1</em>, <em>*</em>, <em>loop=None</em><big>)</big><a class="headerlink" href="#asyncio.BoundedSemaphore" title="Permalink to this definition">¶</a></dt>
<dd><p>A bounded semaphore implementation. Inherit from <a class="reference internal" href="#asyncio.Semaphore" title="asyncio.Semaphore"><tt class="xref py py-class docutils literal"><span class="pre">Semaphore</span></tt></a>.</p>
<p>This raises <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> in <a class="reference internal" href="#asyncio.Semaphore.release" title="asyncio.Semaphore.release"><tt class="xref py py-meth docutils literal"><span class="pre">release()</span></tt></a> if it would
increase the value above the initial value.</p>
</dd></dl>

</div>
</div>
<div class="section" id="queues">
<h2>18.5.7.3. Queues<a class="headerlink" href="#queues" title="Permalink to this headline">¶</a></h2>
<div class="section" id="queue">
<h3>18.5.7.3.1. Queue<a class="headerlink" href="#queue" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="asyncio.Queue">
<em class="property">class </em><tt class="descclassname">asyncio.</tt><tt class="descname">Queue</tt><big>(</big><em>maxsize=0</em>, <em>*</em>, <em>loop=None</em><big>)</big><a class="headerlink" href="#asyncio.Queue" title="Permalink to this definition">¶</a></dt>
<dd><p>A queue, useful for coordinating producer and consumer coroutines.</p>
<p>If <em>maxsize</em> is less than or equal to zero, the queue size is infinite. If
it is an integer greater than <tt class="docutils literal"><span class="pre">0</span></tt>, then <tt class="docutils literal"><span class="pre">yield</span> <span class="pre">from</span> <span class="pre">put()</span></tt> will block
when the queue reaches <em>maxsize</em>, until an item is removed by <a class="reference internal" href="#asyncio.Queue.get" title="asyncio.Queue.get"><tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt></a>.</p>
<p>Unlike the standard library <a class="reference internal" href="queue.html#module-queue" title="queue: A synchronized queue class."><tt class="xref py py-mod docutils literal"><span class="pre">queue</span></tt></a>, you can reliably know this Queue&#8217;s
size with <a class="reference internal" href="#asyncio.Queue.qsize" title="asyncio.Queue.qsize"><tt class="xref py py-meth docutils literal"><span class="pre">qsize()</span></tt></a>, since your single-threaded asyncio application won&#8217;t
be interrupted between calling <a class="reference internal" href="#asyncio.Queue.qsize" title="asyncio.Queue.qsize"><tt class="xref py py-meth docutils literal"><span class="pre">qsize()</span></tt></a> and doing an operation on the
Queue.</p>
<dl class="method">
<dt id="asyncio.Queue.empty">
<tt class="descname">empty</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.Queue.empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if the queue is empty, <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Queue.full">
<tt class="descname">full</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.Queue.full" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <tt class="docutils literal"><span class="pre">True</span></tt> if there are maxsize items in the queue.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the Queue was initialized with <tt class="docutils literal"><span class="pre">maxsize=0</span></tt> (the default), then
<a class="reference internal" href="#asyncio.Queue.full" title="asyncio.Queue.full"><tt class="xref py py-meth docutils literal"><span class="pre">full()</span></tt></a> is never <tt class="docutils literal"><span class="pre">True</span></tt>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="asyncio.Queue.get">
<tt class="descname">get</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.Queue.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove and return an item from the queue.</p>
<p>If you yield from <a class="reference internal" href="#asyncio.Queue.get" title="asyncio.Queue.get"><tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt></a>, wait until a item is available.</p>
<p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Queue.get_nowait">
<tt class="descname">get_nowait</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.Queue.get_nowait" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove and return an item from the queue.</p>
<p>Return an item if one is immediately available, else raise
<a class="reference internal" href="#asyncio.QueueEmpty" title="asyncio.QueueEmpty"><tt class="xref py py-exc docutils literal"><span class="pre">QueueEmpty</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Queue.put">
<tt class="descname">put</tt><big>(</big><em>item</em><big>)</big><a class="headerlink" href="#asyncio.Queue.put" title="Permalink to this definition">¶</a></dt>
<dd><p>Put an item into the queue.</p>
<p>If you yield from <tt class="docutils literal"><span class="pre">put()</span></tt>, wait until a free slot is available before
adding item.</p>
<p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Queue.put_nowait">
<tt class="descname">put_nowait</tt><big>(</big><em>item</em><big>)</big><a class="headerlink" href="#asyncio.Queue.put_nowait" title="Permalink to this definition">¶</a></dt>
<dd><p>Put an item into the queue without blocking.</p>
<p>If no free slot is immediately available, raise <a class="reference internal" href="#asyncio.QueueFull" title="asyncio.QueueFull"><tt class="xref py py-exc docutils literal"><span class="pre">QueueFull</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.Queue.qsize">
<tt class="descname">qsize</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.Queue.qsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of items in the queue.</p>
</dd></dl>

<dl class="attribute">
<dt id="asyncio.Queue.maxsize">
<tt class="descname">maxsize</tt><a class="headerlink" href="#asyncio.Queue.maxsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of items allowed in the queue.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="priorityqueue">
<h3>18.5.7.3.2. PriorityQueue<a class="headerlink" href="#priorityqueue" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="asyncio.PriorityQueue">
<em class="property">class </em><tt class="descclassname">asyncio.</tt><tt class="descname">PriorityQueue</tt><a class="headerlink" href="#asyncio.PriorityQueue" title="Permalink to this definition">¶</a></dt>
<dd><p>A subclass of <a class="reference internal" href="#asyncio.Queue" title="asyncio.Queue"><tt class="xref py py-class docutils literal"><span class="pre">Queue</span></tt></a>; retrieves entries in priority order (lowest
first).</p>
<p>Entries are typically tuples of the form: (priority number, data).</p>
</dd></dl>

</div>
<div class="section" id="lifoqueue">
<h3>18.5.7.3.3. LifoQueue<a class="headerlink" href="#lifoqueue" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="asyncio.LifoQueue">
<em class="property">class </em><tt class="descclassname">asyncio.</tt><tt class="descname">LifoQueue</tt><a class="headerlink" href="#asyncio.LifoQueue" title="Permalink to this definition">¶</a></dt>
<dd><p>A subclass of <a class="reference internal" href="#asyncio.Queue" title="asyncio.Queue"><tt class="xref py py-class docutils literal"><span class="pre">Queue</span></tt></a> that retrieves most recently added entries
first.</p>
</dd></dl>

</div>
<div class="section" id="joinablequeue">
<h3>18.5.7.3.4. JoinableQueue<a class="headerlink" href="#joinablequeue" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="asyncio.JoinableQueue">
<em class="property">class </em><tt class="descclassname">asyncio.</tt><tt class="descname">JoinableQueue</tt><a class="headerlink" href="#asyncio.JoinableQueue" title="Permalink to this definition">¶</a></dt>
<dd><p>A subclass of <a class="reference internal" href="#asyncio.Queue" title="asyncio.Queue"><tt class="xref py py-class docutils literal"><span class="pre">Queue</span></tt></a> with <a class="reference internal" href="#asyncio.JoinableQueue.task_done" title="asyncio.JoinableQueue.task_done"><tt class="xref py py-meth docutils literal"><span class="pre">task_done()</span></tt></a> and <a class="reference internal" href="#asyncio.JoinableQueue.join" title="asyncio.JoinableQueue.join"><tt class="xref py py-meth docutils literal"><span class="pre">join()</span></tt></a>
methods.</p>
<dl class="method">
<dt id="asyncio.JoinableQueue.join">
<tt class="descname">join</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.JoinableQueue.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Block until all items in the queue have been gotten and processed.</p>
<p>The count of unfinished tasks goes up whenever an item is added to the
queue. The count goes down whenever a consumer thread calls
<a class="reference internal" href="#asyncio.JoinableQueue.task_done" title="asyncio.JoinableQueue.task_done"><tt class="xref py py-meth docutils literal"><span class="pre">task_done()</span></tt></a> to indicate that the item was retrieved and all work on
it is complete.  When the count of unfinished tasks drops to zero,
<a class="reference internal" href="#asyncio.JoinableQueue.join" title="asyncio.JoinableQueue.join"><tt class="xref py py-meth docutils literal"><span class="pre">join()</span></tt></a> unblocks.</p>
<p>This method is a <a class="reference internal" href="asyncio-task.html#coroutine"><em>coroutine</em></a>.</p>
</dd></dl>

<dl class="method">
<dt id="asyncio.JoinableQueue.task_done">
<tt class="descname">task_done</tt><big>(</big><big>)</big><a class="headerlink" href="#asyncio.JoinableQueue.task_done" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate that a formerly enqueued task is complete.</p>
<p>Used by queue consumers. For each <a class="reference internal" href="#asyncio.Queue.get" title="asyncio.Queue.get"><tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt></a> used to fetch a task, a
subsequent call to <a class="reference internal" href="#asyncio.JoinableQueue.task_done" title="asyncio.JoinableQueue.task_done"><tt class="xref py py-meth docutils literal"><span class="pre">task_done()</span></tt></a> tells the queue that the processing
on the task is complete.</p>
<p>If a <a class="reference internal" href="#asyncio.JoinableQueue.join" title="asyncio.JoinableQueue.join"><tt class="xref py py-meth docutils literal"><span class="pre">join()</span></tt></a> is currently blocking, it will resume when all items
have been processed (meaning that a <a class="reference internal" href="#asyncio.JoinableQueue.task_done" title="asyncio.JoinableQueue.task_done"><tt class="xref py py-meth docutils literal"><span class="pre">task_done()</span></tt></a> call was received
for every item that had been <a class="reference internal" href="#asyncio.Queue.put" title="asyncio.Queue.put"><tt class="xref py py-meth docutils literal"><span class="pre">put()</span></tt></a> into the queue).</p>
<p>Raises <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt></a> if called more times than there were items
placed in the queue.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="exceptions">
<h3>18.5.7.3.5. Exceptions<a class="headerlink" href="#exceptions" title="Permalink to this headline">¶</a></h3>
<dl class="exception">
<dt id="asyncio.QueueEmpty">
<em class="property">exception </em><tt class="descclassname">asyncio.</tt><tt class="descname">QueueEmpty</tt><a class="headerlink" href="#asyncio.QueueEmpty" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception raised when non-blocking <a class="reference internal" href="#asyncio.Queue.get" title="asyncio.Queue.get"><tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt></a> (or
<a class="reference internal" href="#asyncio.Queue.get_nowait" title="asyncio.Queue.get_nowait"><tt class="xref py py-meth docutils literal"><span class="pre">get_nowait()</span></tt></a>) is called
on a <a class="reference internal" href="#asyncio.Queue" title="asyncio.Queue"><tt class="xref py py-class docutils literal"><span class="pre">Queue</span></tt></a> object which is empty.</p>
</dd></dl>

<dl class="exception">
<dt id="asyncio.QueueFull">
<em class="property">exception </em><tt class="descclassname">asyncio.</tt><tt class="descname">QueueFull</tt><a class="headerlink" href="#asyncio.QueueFull" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception raised when non-blocking <a class="reference internal" href="#asyncio.Queue.put" title="asyncio.Queue.put"><tt class="xref py py-meth docutils literal"><span class="pre">put()</span></tt></a> (or
<a class="reference internal" href="#asyncio.Queue.put_nowait" title="asyncio.Queue.put_nowait"><tt class="xref py py-meth docutils literal"><span class="pre">put_nowait()</span></tt></a>) is called
on a <a class="reference internal" href="#asyncio.Queue" title="asyncio.Queue"><tt class="xref py py-class docutils literal"><span class="pre">Queue</span></tt></a> object which is full.</p>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">18.5.7. Synchronization primitives</a><ul>
<li><a class="reference internal" href="#locks">18.5.7.1. Locks</a><ul>
<li><a class="reference internal" href="#lock">18.5.7.1.1. Lock</a></li>
<li><a class="reference internal" href="#event">18.5.7.1.2. Event</a></li>
<li><a class="reference internal" href="#condition">18.5.7.1.3. Condition</a></li>
</ul>
</li>
<li><a class="reference internal" href="#semaphores">18.5.7.2. Semaphores</a><ul>
<li><a class="reference internal" href="#semaphore">18.5.7.2.1. Semaphore</a></li>
<li><a class="reference internal" href="#boundedsemaphore">18.5.7.2.2. BoundedSemaphore</a></li>
</ul>
</li>
<li><a class="reference internal" href="#queues">18.5.7.3. Queues</a><ul>
<li><a class="reference internal" href="#queue">18.5.7.3.1. Queue</a></li>
<li><a class="reference internal" href="#priorityqueue">18.5.7.3.2. PriorityQueue</a></li>
<li><a class="reference internal" href="#lifoqueue">18.5.7.3.3. LifoQueue</a></li>
<li><a class="reference internal" href="#joinablequeue">18.5.7.3.4. JoinableQueue</a></li>
<li><a class="reference internal" href="#exceptions">18.5.7.3.5. Exceptions</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="asyncio-subprocess.html"
                        title="previous chapter">18.5.6. Subprocess</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="asyncio-dev.html"
                        title="next chapter">18.5.8. Develop with asyncio</a></p>
<h3>This Page</h3>
<ul class="this-page-menu">
  <li><a href="../bugs.html">Report a Bug</a></li>
  <li><a href="../_sources/library/asyncio-sync.txt"
         rel="nofollow">Show Source</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="asyncio-dev.html" title="18.5.8. Develop with asyncio"
             >next</a> |</li>
        <li class="right" >
          <a href="asyncio-subprocess.html" title="18.5.6. Subprocess"
             >previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="http://www.python.org/">Python</a> &raquo;</li>
        <li>
          <span class="version_switcher_placeholder">3.4.1</span>
          <a href="../index.html">Documentation</a> &raquo;
        </li>

          <li><a href="index.html" >The Python Standard Library</a> &raquo;</li>
          <li><a href="ipc.html" >18. Interprocess Communication and Networking</a> &raquo;</li>
          <li><a href="asyncio.html" >18.5. <tt class="docutils literal"><span class="pre">asyncio</span></tt> &#8211; Asynchronous I/O, event loop, coroutines and tasks</a> &raquo;</li> 
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 1990-2014, Python Software Foundation.
    <br />
    The Python Software Foundation is a non-profit corporation.
    <a href="http://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on Jul 09, 2014.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.2.
    </div>

  </body>
</html>