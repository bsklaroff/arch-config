
Event loops
***********

The event loop is the central execution device provided by "asyncio".
It provides multiple facilities, amongst which:

* Registering, executing and cancelling delayed calls (timeouts).

* Creating client and server *transports* for various kinds of
  communication.

* Launching subprocesses and the associated *transports* for
  communication with an external program.

* Delegating costly function calls to a pool of threads.


Event loop policies and the default policy
==========================================

Event loop management is abstracted with a *policy* pattern, to
provide maximal flexibility for custom platforms and frameworks.
Throughout the execution of a process, a single global policy object
manages the event loops available to the process based on the calling
context. A policy is an object implementing the
"AbstractEventLoopPolicy" interface.

For most users of "asyncio", policies never have to be dealt with
explicitly, since the default global policy is sufficient.

The default policy defines context as the current thread, and manages
an event loop per thread that interacts with "asyncio". The module-
level functions "get_event_loop()" and "set_event_loop()" provide
convenient access to event loops managed by the default policy.


Event loop functions
====================

The following functions are convenient shortcuts to accessing the
methods of the global policy. Note that this provides access to the
default policy, unless an alternative policy was set by calling
"set_event_loop_policy()" earlier in the execution of the process.

asyncio.get_event_loop()

   Equivalent to calling "get_event_loop_policy().get_event_loop()".

asyncio.set_event_loop(loop)

   Equivalent to calling
   "get_event_loop_policy().set_event_loop(loop)".

asyncio.new_event_loop()

   Equivalent to calling "get_event_loop_policy().new_event_loop()".


Event loop policy interface
===========================

An event loop policy must implement the following interface:

class class asyncio.AbstractEventLoopPolicy

   get_event_loop()

   Get the event loop for the current context. Returns an event loop
   object implementing the "BaseEventLoop" interface, or raises an
   exception in case no event loop has been set for the current
   context and the current policy does not specify to create one. It
   should never return "None".

   set_event_loop(loop)

   Set the event loop for the current context to *loop*.

   new_event_loop()

   Create and return a new event loop object according to this
   policy's rules. If there's need to set this loop as the event loop
   for the current context, "set_event_loop()" must be called
   explicitly.


Access to the global loop policy
================================

asyncio.get_event_loop_policy()

   Get the current event loop policy.

asyncio.set_event_loop_policy(policy)

   Set the current event loop policy. If *policy* is "None", the
   default policy is restored.


Run an event loop
=================

BaseEventLoop.run_forever()

   Run until "stop()" is called.

BaseEventLoop.run_until_complete(future)

   Run until the "Future" is done.

   If the argument is a *coroutine*, it is wrapped in a "Task".

   Return the Future's result, or raise its exception.

BaseEventLoop.is_running()

   Returns running status of event loop.

BaseEventLoop.stop()

   Stop running the event loop.

   Every callback scheduled before "stop()" is called will run.
   Callback scheduled after "stop()" is called won't.  However, those
   callbacks will run if "run_forever()" is called again later.

BaseEventLoop.is_closed()

   Returns "True" if the event loop was closed.

   New in version 3.4.2.

BaseEventLoop.close()

   Close the event loop. The loop should not be running.

   This clears the queues and shuts down the executor, but does not
   wait for the executor to finish.

   The event loop must not be running.

   This is idempotent and irreversible. No other methods should be
   called after this one.


Calls
=====

BaseEventLoop.call_soon(callback, *args)

   Arrange for a callback to be called as soon as possible.

   This operates as a FIFO queue, callbacks are called in the order in
   which they are registered.  Each callback will be called exactly
   once.

   Any positional arguments after the callback will be passed to the
   callback when it is called.

   An instance of "asyncio.Handle" is returned.

BaseEventLoop.call_soon_threadsafe(callback, *args)

   Like "call_soon()", but thread safe.


Delayed calls
=============

The event loop has its own internal clock for computing timeouts.
Which clock is used depends on the (platform-specific) event loop
implementation; ideally it is a monotonic clock.  This will generally
be a different clock than "time.time()".

Note: Timeouts (relative *delay* or absolute *when*) should not
  exceed one day.

BaseEventLoop.call_later(delay, callback, *args)

   Arrange for the *callback* to be called after the given *delay*
   seconds (either an int or float).

   An instance of "asyncio.Handle" is returned.

   *callback* will be called exactly once per call to "call_later()".
   If two callbacks are scheduled for exactly the same time, it is
   undefined which will be called first.

   The optional positional *args* will be passed to the callback when
   it is called. If you want the callback to be called with some named
   arguments, use a closure or "functools.partial()".

BaseEventLoop.call_at(when, callback, *args)

   Arrange for the *callback* to be called at the given absolute
   timestamp *when* (an int or float), using the same time reference
   as "time()".

   This method's behavior is the same as "call_later()".

BaseEventLoop.time()

   Return the current time, as a "float" value, according to the event
   loop's internal clock.

See also: The "asyncio.sleep()" function.


Creating connections
====================

BaseEventLoop.create_connection(protocol_factory, host=None, port=None, *, ssl=None, family=0, proto=0, flags=0, sock=None, local_addr=None, server_hostname=None)

   Create a streaming transport connection to a given Internet *host*
   and *port*: socket family "AF_INET" or "AF_INET6" depending on
   *host* (or *family* if specified), socket type "SOCK_STREAM".
   *protocol_factory* must be a callable returning a *protocol*
   instance.

   This method is a *coroutine* which will try to establish the
   connection in the background.  When successful, the coroutine
   returns a "(transport, protocol)" pair.

   The chronological synopsis of the underlying operation is as
   follows:

   1. The connection is established, and a *transport* is created
      to represent it.

   2. *protocol_factory* is called without arguments and must
      return a *protocol* instance.

   3. The protocol instance is tied to the transport, and its
      "connection_made()" method is called.

   4. The coroutine returns successfully with the "(transport,
      protocol)" pair.

   The created transport is an implementation-dependent bidirectional
   stream.

   Note: *protocol_factory* can be any kind of callable, not
     necessarily a class.  For example, if you want to use a pre-
     created protocol instance, you can pass "lambda: my_protocol".

   Options allowing to change how the connection is created:

   * *ssl*: if given and not false, a SSL/TLS transport is created
     (by default a plain TCP transport is created).  If *ssl* is a
     "ssl.SSLContext" object, this context is used to create the
     transport; if *ssl* is "True", a context with some unspecified
     default settings is used.

     See also: *SSL/TLS security considerations*

   * *server_hostname*, is only for use together with *ssl*, and
     sets or overrides the hostname that the target server's
     certificate will be matched against.  By default the value of the
     *host* argument is used.  If *host* is empty, there is no default
     and you must pass a value for *server_hostname*.  If
     *server_hostname* is an empty string, hostname matching is
     disabled (which is a serious security risk, allowing for man-in-
     the-middle-attacks).

   * *family*, *proto*, *flags* are the optional address family,
     protocol and flags to be passed through to getaddrinfo() for
     *host* resolution. If given, these should all be integers from
     the corresponding "socket" module constants.

   * *sock*, if given, should be an existing, already connected
     "socket.socket" object to be used by the transport. If *sock* is
     given, none of *host*, *port*, *family*, *proto*, *flags* and
     *local_addr* should be specified.

   * *local_addr*, if given, is a "(local_host, local_port)" tuple
     used to bind the socket to locally.  The *local_host* and
     *local_port* are looked up using getaddrinfo(), similarly to
     *host* and *port*.

   See also: The "open_connection()" function can be used to get a
     pair of ("StreamReader", "StreamWriter") instead of a protocol.

BaseEventLoop.create_datagram_endpoint(protocol_factory, local_addr=None, remote_addr=None, *, family=0, proto=0, flags=0)

   Create datagram connection: socket family "AF_INET" or "AF_INET6"
   depending on *host* (or *family* if specified), socket type
   "SOCK_DGRAM".

   This method is a *coroutine* which will try to establish the
   connection in the background.  When successful, the coroutine
   returns a "(transport, protocol)" pair.

   See the "BaseEventLoop.create_connection()" method for parameters.

BaseEventLoop.create_unix_connection(protocol_factory, path, *, ssl=None, sock=None, server_hostname=None)

   Create UNIX connection: socket family "AF_UNIX", socket type
   "SOCK_STREAM". The "AF_UNIX" socket family is used to communicate
   between processes on the same machine efficiently.

   This method is a *coroutine* which will try to establish the
   connection in the background.  When successful, the coroutine
   returns a "(transport, protocol)" pair.

   See the "BaseEventLoop.create_connection()" method for parameters.

   Availability: UNIX.


Creating listening connections
==============================

BaseEventLoop.create_server(protocol_factory, host=None, port=None, *, family=socket.AF_UNSPEC, flags=socket.AI_PASSIVE, sock=None, backlog=100, ssl=None, reuse_address=None)

   Create a TCP server bound to host and port. Return an
   "AbstractServer" object which can be used to stop the service.

   This method is a *coroutine*.

   If *host* is an empty string or None all interfaces are assumed and
   a list of multiple sockets will be returned (most likely one for
   IPv4 and another one for IPv6).

   *family* can be set to either "AF_INET" or "AF_INET6" to force the
   socket to use IPv4 or IPv6. If not set it will be determined from
   host (defaults to "AF_UNSPEC").

   *flags* is a bitmask for "getaddrinfo()".

   *sock* can optionally be specified in order to use a preexisting
   socket object.

   *backlog* is the maximum number of queued connections passed to
   "listen()" (defaults to 100).

   ssl can be set to an "SSLContext" to enable SSL over the accepted
   connections.

   *reuse_address* tells the kernel to reuse a local socket in
   TIME_WAIT state, without waiting for its natural timeout to expire.
   If not specified will automatically be set to True on UNIX.

   See also: The function "start_server()" creates a
     ("StreamReader", "StreamWriter") pair and calls back a function
     with this pair.

BaseEventLoop.create_unix_server(protocol_factory, path=None, *, sock=None, backlog=100, ssl=None)

   Similar to "BaseEventLoop.create_server()", but specific to the
   socket family "AF_UNIX".

   Availability: UNIX.


Watch file descriptors
======================

BaseEventLoop.add_reader(fd, callback, *args)

   Start watching the file descriptor for read availability and then
   call the *callback* with specified arguments.

BaseEventLoop.remove_reader(fd)

   Stop watching the file descriptor for read availability.

BaseEventLoop.add_writer(fd, callback, *args)

   Start watching the file descriptor for write availability and then
   call the *callback* with specified arguments.

BaseEventLoop.remove_writer(fd)

   Stop watching the file descriptor for write availability.


Low-level socket operations
===========================

BaseEventLoop.sock_recv(sock, nbytes)

   Receive data from the socket.  The return value is a bytes object
   representing the data received.  The maximum amount of data to be
   received at once is specified by *nbytes*.

   This method is a *coroutine*.

   See also: The "socket.socket.recv()" method.

BaseEventLoop.sock_sendall(sock, data)

   Send data to the socket.  The socket must be connected to a remote
   socket. This method continues to send data from *data* until either
   all data has been sent or an error occurs.  "None" is returned on
   success.  On error, an exception is raised, and there is no way to
   determine how much data, if any, was successfully processed by the
   receiving end of the connection.

   This method is a *coroutine*.

   See also: The "socket.socket.sendall()" method.

BaseEventLoop.sock_connect(sock, address)

   Connect to a remote socket at *address*.

   The *address* must be already resolved to avoid the trap of hanging
   the entire event loop when the address requires doing a DNS lookup.
   For example, it must be an IP address, not an hostname, for
   "AF_INET" and "AF_INET6" address families. Use "getaddrinfo()" to
   resolve the hostname asynchronously.

   This method is a *coroutine*.

   See also: The "BaseEventLoop.create_connection()" method, the
     "open_connection()" function and the "socket.socket.connect()"
     method.

BaseEventLoop.sock_accept(sock)

   Accept a connection. The socket must be bound to an address and
   listening for connections. The return value is a pair "(conn,
   address)" where *conn* is a *new* socket object usable to send and
   receive data on the connection, and *address* is the address bound
   to the socket on the other end of the connection.

   This method is a *coroutine*.

   See also: The "BaseEventLoop.create_server()" method, the
     "start_server()" function and the "socket.socket.accept()"
     method.


Resolve host name
=================

BaseEventLoop.getaddrinfo(host, port, *, family=0, type=0, proto=0, flags=0)

   This method is a *coroutine*, similar to "socket.getaddrinfo()"
   function but non-blocking.

BaseEventLoop.getnameinfo(sockaddr, flags=0)

   This method is a *coroutine*, similar to "socket.getnameinfo()"
   function but non-blocking.


Connect pipes
=============

BaseEventLoop.connect_read_pipe(protocol_factory, pipe)

   Register read pipe in eventloop. Set the *pipe* to non-blocking
   mode.

   *protocol_factory* should instantiate object with "Protocol"
   interface.  *pipe* is a *file-like object*. Return pair
   "(transport, protocol)", where *transport* supports the
   "ReadTransport" interface.

   This method is a *coroutine*.

BaseEventLoop.connect_write_pipe(protocol_factory, pipe)

   Register write pipe in eventloop.

   *protocol_factory* should instantiate object with "BaseProtocol"
   interface.  Pipe is file-like object already switched to
   nonblocking. Return pair (transport, protocol), where transport
   support "WriteTransport" interface.

   This method is a *coroutine*.

See also: The "BaseEventLoop.subprocess_exec()" and
  "BaseEventLoop.subprocess_shell()" methods.


UNIX signals
============

Availability: UNIX only.

BaseEventLoop.add_signal_handler(signum, callback, *args)

   Add a handler for a signal.

   Raise "ValueError" if the signal number is invalid or uncatchable.
   Raise "RuntimeError" if there is a problem setting up the handler.

BaseEventLoop.remove_signal_handler(sig)

   Remove a handler for a signal.

   Return "True" if a signal handler was removed, "False" if not.

See also: The "signal" module.


Executor
========

Call a function in an "Executor" (pool of threads or pool of
processes). By default, an event loop uses a thread pool executor
("ThreadPoolExecutor").

BaseEventLoop.run_in_executor(executor, callback, *args)

   Arrange for a callback to be called in the specified executor.

   The *executor* argument should be an "Executor" instance. The
   default executor is used if *executor* is "None".

   This method is a *coroutine*.

BaseEventLoop.set_default_executor(executor)

   Set the default executor used by "run_in_executor()".


Error Handling API
==================

Allows to customize how exceptions are handled in the event loop.

BaseEventLoop.set_exception_handler(handler)

   Set *handler* as the new event loop exception handler.

   If *handler* is "None", the default exception handler will be set.

   If *handler* is a callable object, it should have a matching
   signature to "(loop, context)", where "loop" will be a reference to
   the active event loop, "context" will be a "dict" object (see
   "call_exception_handler()" documentation for details about
   context).

BaseEventLoop.default_exception_handler(context)

   Default exception handler.

   This is called when an exception occurs and no exception handler is
   set, and can be called by a custom exception handler that wants to
   defer to the default behavior.

   *context* parameter has the same meaning as in
   "call_exception_handler()".

BaseEventLoop.call_exception_handler(context)

   Call the current event loop exception handler.

   *context* is a "dict" object containing the following keys (new
   keys may be introduced later):

   * 'message': Error message;

   * 'exception' (optional): Exception object;

   * 'future' (optional): "asyncio.Future" instance;

   * 'handle' (optional): "asyncio.Handle" instance;

   * 'protocol' (optional): *Protocol* instance;

   * 'transport' (optional): *Transport* instance;

   * 'socket' (optional): "socket.socket" instance.

   Note: Note: this method should not be overloaded in subclassed
     event loops.  For any custom exception handling, use
     "set_exception_handler()" method.


Debug mode
==========

BaseEventLoop.get_debug()

   Get the debug mode ("bool") of the event loop.

   The default value is "True" if the environment variable
   "PYTHONASYNCIODEBUG" is set to a non-empty string, "False"
   otherwise.

   New in version 3.4.2.

BaseEventLoop.set_debug(enabled: bool)

   Set the debug mode of the event loop.

   New in version 3.4.2.

See also: The *debug mode of asyncio*.


Server
======

class class asyncio.AbstractServer

   Abstract server returned by "BaseEventLoop.create_server()".

   close()

      Stop serving.  This leaves existing connections open.

   wait_closed()

      A *coroutine* to wait until service is closed.


Handle
======

class class asyncio.Handle

   A callback wrapper object returned by "BaseEventLoop.call_soon()",
   "BaseEventLoop.call_soon_threadsafe()",
   "BaseEventLoop.call_later()", and "BaseEventLoop.call_at()".

   cancel()

   Cancel the call.


Example: Hello World (callback)
===============================

Print "Hello World" every two seconds, using a callback:

   import asyncio

   def print_and_repeat(loop):
       print('Hello World')
       loop.call_later(2, print_and_repeat, loop)

   loop = asyncio.get_event_loop()
   loop.call_soon(print_and_repeat, loop)
   try:
       loop.run_forever()
   finally:
       loop.close()

See also: *Hello World example using a coroutine*.


Example: Set signal handlers for SIGINT and SIGTERM
===================================================

Register handlers for signals "SIGINT" and "SIGTERM":

   import asyncio
   import functools
   import os
   import signal

   def ask_exit(signame):
       print("got signal %s: exit" % signame)
       loop.stop()

   loop = asyncio.get_event_loop()
   for signame in ('SIGINT', 'SIGTERM'):
       loop.add_signal_handler(getattr(signal, signame),
                               functools.partial(ask_exit, signame))

   print("Event loop running forever, press CTRL+c to interrupt.")
   print("pid %s: send SIGINT or SIGTERM to exit." % os.getpid())
   try:
       loop.run_forever()
   finally:
       loop.close()
